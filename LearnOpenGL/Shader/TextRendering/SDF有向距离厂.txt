太好了！让我详细分析片段着色器的代码和算法。这是 SDF 渲染的核心部分！

Read file: LearnOpenGL/Shader/TextRendering/text.frag
太棒了！让我详细分析这个片段着色器的算法。这是 SDF 渲染的精华所在！

## 1. 片段着色器算法详解

### 1.1 输入和输出

```glsl
in vec2 TexCoords;    // 输入：当前像素的纹理坐标
out vec4 color;       // 输出：最终的颜色值
```

**通俗理解**：每个像素都会调用这个函数，`TexCoords` 告诉我们在图集中的哪个位置采样。

### 1.2 关键参数

```glsl
uniform float u_outlineWidth = 0.05;  // 轮廓宽度
uniform float u_smoothness = 0.02;    // 平滑度
```

**这些参数的作用**：
- `u_smoothness`：控制文字边缘的锐利程度
- `u_outlineWidth`：控制轮廓的粗细

## 2. 核心算法：SDF 距离采样

```glsl
float distance = texture(text, TexCoords).r;
```

**这是关键步骤**：
- 从 SDF 纹理中采样得到距离值（0-1范围）
- 0.5 是文字边缘，小于0.5是文字内部，大于0.5是文字外部

**距离值的含义**：
```
距离值范围：
0.0 ──── 0.5 ──── 1.0
文字内部  文字边缘  文字外部
```

## 3. 主文字 Alpha 计算

```glsl
float mainAlpha = smoothstep(0.5 - u_smoothness, 0.5 + u_smoothness, distance);
```

**`smoothstep` 函数的作用**：
- 在指定范围内创建平滑的过渡
- 避免锯齿边缘，实现抗锯齿效果

**具体过程**：
```
smoothstep(0.48, 0.52, distance) 的效果：

distance = 0.47 → Alpha = 0.0  (完全透明)
distance = 0.48 → Alpha = 0.0  (开始出现)
distance = 0.50 → Alpha = 0.5  (半透明)
distance = 0.52 → Alpha = 1.0  (完全不透明)
distance = 0.53 → Alpha = 1.0  (完全不透明)
```

**可视化**：
```
距离值:    0.47  0.48  0.49  0.50  0.51  0.52  0.53
Alpha值:   0.0   0.0   0.25  0.5   0.75  1.0   1.0
结果:      透明  透明  半透明 半透明 半透明 不透明 不透明
```

## 4. 轮廓 Alpha 计算

```glsl
float outlineAlpha = 0.0;
if (u_enableOutline) {
    outlineAlpha = smoothstep(0.5 - u_outlineWidth - u_smoothness, 
                             0.5 - u_outlineWidth + u_smoothness, distance);
}
```

**轮廓的原理**：
- 轮廓在文字外部，所以距离值更大
- `0.5 - u_outlineWidth` 是轮廓的内边缘
- `0.5 - u_outlineWidth + u_smoothness` 是轮廓的外边缘

**例子**（假设 `u_outlineWidth = 0.05`）：
```
轮廓范围：0.5 - 0.05 - 0.02 = 0.43 到 0.5 - 0.05 + 0.02 = 0.47

distance = 0.42 → Alpha = 0.0  (轮廓外)
distance = 0.43 → Alpha = 0.0  (轮廓开始)
distance = 0.45 → Alpha = 0.5  (轮廓中间)
distance = 0.47 → Alpha = 1.0  (轮廓内)
distance = 0.48 → Alpha = 1.0  (轮廓内)
```

## 5. 阴影 Alpha 计算

```glsl
float shadowAlpha = 0.0;
if (u_enableShadow) {
    vec2 shadowTexCoords = TexCoords - u_shadowOffset / vec2(1024.0, 1024.0);
    if (shadowTexCoords.x >= 0.0 && shadowTexCoords.x <= 1.0 && 
        shadowTexCoords.y >= 0.0 && shadowTexCoords.y <= 1.0) {
        float shadowDistance = texture(text, shadowTexCoords).r;
        shadowAlpha = smoothstep(0.5 - u_shadowBlur, 0.5 + u_shadowBlur, shadowDistance);
    }
}
```

**阴影的原理**：
1. **偏移采样**：`TexCoords - u_shadowOffset / vec2(1024.0, 1024.0)`
   - 在当前位置的右下方采样
   - 除以1024是因为纹理坐标是0-1范围

2. **边界检查**：确保偏移后的坐标还在纹理范围内

3. **模糊阴影**：使用 `u_shadowBlur` 让阴影更柔和

## 6. 颜色混合算法

```glsl
vec4 finalColor = vec4(0.0, 0.0, 0.0, 0.0);  // 初始透明

// 添加阴影
if (u_enableShadow) {
    finalColor = mix(finalColor, vec4(0.0, 0.0, 0.0, 0.5), shadowAlpha);
}

// 添加轮廓
if (u_enableOutline) {
    finalColor = mix(finalColor, u_outlineColor, outlineAlpha);
}

// 添加主文字
finalColor = mix(finalColor, vec4(textColor, 1.0), mainAlpha);
```

**`mix` 函数的作用**：
```glsl
mix(a, b, t) = a * (1 - t) + b * t
```

**混合顺序**：
1. **阴影**：黑色半透明 → 背景
2. **轮廓**：轮廓颜色 → 阴影之上
3. **主文字**：文字颜色 → 最上层

**例子**：
```
假设某个像素：
shadowAlpha = 0.3
outlineAlpha = 0.8  
mainAlpha = 0.9

混合过程：
1. finalColor = mix(透明, 黑色半透明, 0.3) = 黑色30%透明度
2. finalColor = mix(黑色30%, 轮廓色, 0.8) = 轮廓色80% + 黑色30%*20%
3. finalColor = mix(上一步结果, 文字色, 0.9) = 文字色90% + 上一步结果10%
```

## 7. 算法总结

**SDF 渲染的核心思想**：
1. **距离采样**：从 SDF 纹理获取距离值
2. **平滑过渡**：用 `smoothstep` 创建抗锯齿边缘
3. **多层渲染**：阴影 → 轮廓 → 主文字
4. **Alpha 混合**：用 `mix` 函数实现透明效果

**为什么这样效果好**：
- **抗锯齿**：`smoothstep` 提供平滑过渡
- **可缩放**：SDF 纹理可以任意放大缩小
- **特效丰富**：可以轻松添加轮廓、阴影等效果
- **性能高效**：只需要一次纹理采样就能渲染复杂效果

这就是为什么 SDF 字体渲染既美观又高效的原因！